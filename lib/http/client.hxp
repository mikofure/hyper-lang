// Hyper HTTP Library - http/client.hxp
// Provides HTTP client functionality for network requests

import { HypError, createError } from '../mikohyper/core.hxp';

module http.client {
    // HTTP types
    export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';

    export type HttpHeaders = {
        [key: string]: string
    };

    export type RequestConfig = {
        method?: HttpMethod,
        headers?: HttpHeaders,
        body?: any,
        timeout?: number,
        credentials?: 'omit' | 'same-origin' | 'include',
        mode?: 'cors' | 'no-cors' | 'same-origin',
        cache?: 'default' | 'no-cache' | 'reload' | 'force-cache' | 'only-if-cached',
        redirect?: 'follow' | 'error' | 'manual',
        signal?: AbortSignal
    };

    export type HttpResponse<T = any> = {
        data: T,
        status: number,
        statusText: string,
        headers: HttpHeaders,
        config: RequestConfig,
        request?: any
    };

    export type RequestInterceptor = (config: RequestConfig) => RequestConfig | Promise<RequestConfig>;
    export type ResponseInterceptor = (response: HttpResponse) => HttpResponse | Promise<HttpResponse>;
    export type ErrorInterceptor = (error: any) => any;

    // HTTP Client class
    export class HttpClient {
        private baseURL: string = '';
        private defaultHeaders: HttpHeaders = {};
        private defaultTimeout: number = 30000;
        private requestInterceptors: RequestInterceptor[] = [];
        private responseInterceptors: ResponseInterceptor[] = [];
        private errorInterceptors: ErrorInterceptor[] = [];

        constructor(config?: {
            baseURL?: string,
            headers?: HttpHeaders,
            timeout?: number
        }) {
            if (config) {
                this.baseURL = config.baseURL || '';
                this.defaultHeaders = config.headers || {};
                this.defaultTimeout = config.timeout || 30000;
            }
        }

        // Interceptor management
        addRequestInterceptor(interceptor: RequestInterceptor): void {
            this.requestInterceptors.push(interceptor);
        }

        addResponseInterceptor(interceptor: ResponseInterceptor): void {
            this.responseInterceptors.push(interceptor);
        }

        addErrorInterceptor(interceptor: ErrorInterceptor): void {
            this.errorInterceptors.push(interceptor);
        }

        // Core request method
        async request<T = any>(url: string, config: RequestConfig = {}): Promise<HttpResponse<T>> {
            try {
                // Apply request interceptors
                let finalConfig = { ...config };
                for (const interceptor of this.requestInterceptors) {
                    finalConfig = await interceptor(finalConfig);
                }

                // Build final URL
                const finalUrl = this.buildUrl(url);

                // Prepare headers
                const headers = {
                    ...this.defaultHeaders,
                    ...finalConfig.headers
                };

                // Prepare request options
                const requestOptions: RequestInit = {
                    method: finalConfig.method || 'GET',
                    headers,
                    credentials: finalConfig.credentials,
                    mode: finalConfig.mode,
                    cache: finalConfig.cache,
                    redirect: finalConfig.redirect,
                    signal: finalConfig.signal
                };

                // Add body if present
                if (finalConfig.body) {
                    if (typeof finalConfig.body === 'object') {
                        requestOptions.body = JSON.stringify(finalConfig.body);
                        headers['Content-Type'] = headers['Content-Type'] || 'application/json';
                    } else {
                        requestOptions.body = finalConfig.body;
                    }
                }

                // Set up timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                }, finalConfig.timeout || this.defaultTimeout);

                if (!requestOptions.signal) {
                    requestOptions.signal = controller.signal;
                }

                // Make the request
                const response = await fetch(finalUrl, requestOptions);
                clearTimeout(timeoutId);

                // Parse response
                let data: T;
                const contentType = response.headers.get('content-type');
                
                if (contentType && contentType.includes('application/json')) {
                    data = await response.json();
                } else if (contentType && contentType.includes('text/')) {
                    data = await response.text() as any;
                } else {
                    data = await response.blob() as any;
                }

                // Build response object
                const httpResponse: HttpResponse<T> = {
                    data,
                    status: response.status,
                    statusText: response.statusText,
                    headers: this.parseHeaders(response.headers),
                    config: finalConfig,
                    request: requestOptions
                };

                // Check if response is successful
                if (!response.ok) {
                    throw createError(
                        `HTTP Error: ${response.status} ${response.statusText}`,
                        'HTTP_ERROR',
                        { response: httpResponse }
                    );
                }

                // Apply response interceptors
                let finalResponse = httpResponse;
                for (const interceptor of this.responseInterceptors) {
                    finalResponse = await interceptor(finalResponse);
                }

                return finalResponse;

            } catch (error) {
                // Apply error interceptors
                let finalError = error;
                for (const interceptor of this.errorInterceptors) {
                    finalError = await interceptor(finalError);
                }
                throw finalError;
            }
        }

        // Convenience methods
        async get<T = any>(url: string, config?: RequestConfig): Promise<HttpResponse<T>> {
            return this.request<T>(url, { ...config, method: 'GET' });
        }

        async post<T = any>(url: string, data?: any, config?: RequestConfig): Promise<HttpResponse<T>> {
            return this.request<T>(url, { ...config, method: 'POST', body: data });
        }

        async put<T = any>(url: string, data?: any, config?: RequestConfig): Promise<HttpResponse<T>> {
            return this.request<T>(url, { ...config, method: 'PUT', body: data });
        }

        async delete<T = any>(url: string, config?: RequestConfig): Promise<HttpResponse<T>> {
            return this.request<T>(url, { ...config, method: 'DELETE' });
        }

        async patch<T = any>(url: string, data?: any, config?: RequestConfig): Promise<HttpResponse<T>> {
            return this.request<T>(url, { ...config, method: 'PATCH', body: data });
        }

        async head<T = any>(url: string, config?: RequestConfig): Promise<HttpResponse<T>> {
            return this.request<T>(url, { ...config, method: 'HEAD' });
        }

        async options<T = any>(url: string, config?: RequestConfig): Promise<HttpResponse<T>> {
            return this.request<T>(url, { ...config, method: 'OPTIONS' });
        }

        // Utility methods
        private buildUrl(url: string): string {
            if (url.startsWith('http://') || url.startsWith('https://')) {
                return url;
            }
            return this.baseURL + (url.startsWith('/') ? url : '/' + url);
        }

        private parseHeaders(headers: Headers): HttpHeaders {
            const result: HttpHeaders = {};
            headers.forEach((value, key) => {
                result[key] = value;
            });
            return result;
        }

        // Configuration methods
        setBaseURL(baseURL: string): void {
            this.baseURL = baseURL;
        }

        setDefaultHeader(key: string, value: string): void {
            this.defaultHeaders[key] = value;
        }

        removeDefaultHeader(key: string): void {
            delete this.defaultHeaders[key];
        }

        setTimeout(timeout: number): void {
            this.defaultTimeout = timeout;
        }
    }

    // Default client instance
    export const http = new HttpClient();

    // Utility functions
    export function createClient(config?: {
        baseURL?: string,
        headers?: HttpHeaders,
        timeout?: number
    }): HttpClient {
        return new HttpClient(config);
    }

    export function isHttpError(error: any): error is HypError {
        return error instanceof HypError && error.code === 'HTTP_ERROR';
    }

    export function getErrorResponse(error: any): HttpResponse | null {
        if (isHttpError(error) && error.context?.response) {
            return error.context.response;
        }
        return null;
    }

    // Common interceptors
    export const interceptors = {
        // Add authorization header
        auth: (token: string) => (config: RequestConfig): RequestConfig => {
            return {
                ...config,
                headers: {
                    ...config.headers,
                    'Authorization': `Bearer ${token}`
                }
            };
        },

        // Log requests
        logger: (config: RequestConfig): RequestConfig => {
            console.log(`HTTP ${config.method || 'GET'}:`, config);
            return config;
        },

        // Retry on failure
        retry: (maxRetries: number = 3, delay: number = 1000) => {
            return async (error: any): Promise<any> => {
                if (error.retryCount >= maxRetries) {
                    throw error;
                }
                
                error.retryCount = (error.retryCount || 0) + 1;
                await new Promise(resolve => setTimeout(resolve, delay * error.retryCount));
                
                // Re-throw to trigger retry
                throw error;
            };
        }
    };
}