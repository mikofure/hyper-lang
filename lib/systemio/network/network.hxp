// Hyper System I/O Library - systemio/network/network.hxp
// Provides network utilities and operations

import { HypError, createError } from '../../mikohyper/core.hxp';

module systemio.network.network {
    // Network types
    export type NetworkInterface = {
        name: string,
        address: string,
        netmask: string,
        family: 'IPv4' | 'IPv6',
        mac: string,
        internal: boolean,
        cidr: string
    };

    export type PingResult = {
        host: string,
        alive: boolean,
        time?: number,
        error?: string
    };

    export type PortScanResult = {
        host: string,
        port: number,
        open: boolean,
        service?: string,
        banner?: string
    };

    export type DNSRecord = {
        name: string,
        type: 'A' | 'AAAA' | 'CNAME' | 'MX' | 'TXT' | 'NS' | 'SOA',
        value: string,
        ttl: number
    };

    export type NetworkStats = {
        interface: string,
        bytesReceived: number,
        bytesSent: number,
        packetsReceived: number,
        packetsSent: number,
        errorsReceived: number,
        errorsSent: number,
        droppedReceived: number,
        droppedSent: number
    };

    export type ConnectionInfo = {
        localAddress: string,
        localPort: number,
        remoteAddress: string,
        remotePort: number,
        state: 'ESTABLISHED' | 'LISTEN' | 'CLOSE_WAIT' | 'TIME_WAIT' | 'SYN_SENT' | 'SYN_RECV',
        protocol: 'TCP' | 'UDP',
        pid?: number,
        process?: string
    };

    // Network utilities class
    export class NetworkUtils {
        // Network interface information
        async getNetworkInterfaces(): Promise<NetworkInterface[]> {
            try {
                if (typeof window !== 'undefined') {
                    return this.getNetworkInterfacesBrowser();
                } else {
                    return this.getNetworkInterfacesNode();
                }
            } catch (error) {
                throw createError(
                    'Failed to get network interfaces',
                    'NETWORK_INTERFACES_ERROR',
                    { error }
                );
            }
        }

        async getPublicIP(): Promise<string> {
            try {
                // Use a public IP service
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                return data.ip;
            } catch (error) {
                throw createError(
                    'Failed to get public IP address',
                    'PUBLIC_IP_ERROR',
                    { error }
                );
            }
        }

        async getLocalIP(): Promise<string> {
            try {
                const interfaces = await this.getNetworkInterfaces();
                const localInterface = interfaces.find(iface => 
                    !iface.internal && iface.family === 'IPv4'
                );
                return localInterface?.address || '127.0.0.1';
            } catch (error) {
                throw createError(
                    'Failed to get local IP address',
                    'LOCAL_IP_ERROR',
                    { error }
                );
            }
        }

        // Network connectivity
        async ping(host: string, timeout: number = 5000): Promise<PingResult> {
            try {
                if (typeof window !== 'undefined') {
                    return this.pingBrowser(host, timeout);
                } else {
                    return this.pingNode(host, timeout);
                }
            } catch (error) {
                return {
                    host,
                    alive: false,
                    error: error.message || 'Ping failed'
                };
            }
        }

        async isHostReachable(host: string, port?: number, timeout: number = 5000): Promise<boolean> {
            try {
                if (port) {
                    const result = await this.scanPort(host, port, timeout);
                    return result.open;
                } else {
                    const result = await this.ping(host, timeout);
                    return result.alive;
                }
            } catch {
                return false;
            }
        }

        async scanPort(host: string, port: number, timeout: number = 5000): Promise<PortScanResult> {
            try {
                if (typeof window !== 'undefined') {
                    return this.scanPortBrowser(host, port, timeout);
                } else {
                    return this.scanPortNode(host, port, timeout);
                }
            } catch (error) {
                return {
                    host,
                    port,
                    open: false,
                    error: error.message || 'Port scan failed'
                };
            }
        }

        async scanPorts(host: string, ports: number[], timeout: number = 5000): Promise<PortScanResult[]> {
            const results: PortScanResult[] = [];
            
            // Scan ports in parallel with concurrency limit
            const concurrency = 10;
            for (let i = 0; i < ports.length; i += concurrency) {
                const batch = ports.slice(i, i + concurrency);
                const batchResults = await Promise.all(
                    batch.map(port => this.scanPort(host, port, timeout))
                );
                results.push(...batchResults);
            }
            
            return results;
        }

        // DNS operations
        async resolveDNS(hostname: string, recordType: 'A' | 'AAAA' | 'CNAME' | 'MX' | 'TXT' | 'NS' = 'A'): Promise<DNSRecord[]> {
            try {
                if (typeof window !== 'undefined') {
                    return this.resolveDNSBrowser(hostname, recordType);
                } else {
                    return this.resolveDNSNode(hostname, recordType);
                }
            } catch (error) {
                throw createError(
                    `Failed to resolve DNS for ${hostname}`,
                    'DNS_RESOLVE_ERROR',
                    { hostname, recordType, error }
                );
            }
        }

        async reverseDNS(ip: string): Promise<string> {
            try {
                if (typeof window !== 'undefined') {
                    return this.reverseDNSBrowser(ip);
                } else {
                    return this.reverseDNSNode(ip);
                }
            } catch (error) {
                throw createError(
                    `Failed to perform reverse DNS lookup for ${ip}`,
                    'REVERSE_DNS_ERROR',
                    { ip, error }
                );
            }
        }

        // Network statistics
        async getNetworkStats(): Promise<NetworkStats[]> {
            try {
                if (typeof window !== 'undefined') {
                    throw createError(
                        'Network statistics not available in browser environment',
                        'OPERATION_NOT_SUPPORTED'
                    );
                } else {
                    return this.getNetworkStatsNode();
                }
            } catch (error) {
                throw createError(
                    'Failed to get network statistics',
                    'NETWORK_STATS_ERROR',
                    { error }
                );
            }
        }

        async getActiveConnections(): Promise<ConnectionInfo[]> {
            try {
                if (typeof window !== 'undefined') {
                    throw createError(
                        'Active connections not available in browser environment',
                        'OPERATION_NOT_SUPPORTED'
                    );
                } else {
                    return this.getActiveConnectionsNode();
                }
            } catch (error) {
                throw createError(
                    'Failed to get active connections',
                    'ACTIVE_CONNECTIONS_ERROR',
                    { error }
                );
            }
        }

        // Utility functions
        isValidIP(ip: string): boolean {
            const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
            const ipv6Regex = /^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
            return ipv4Regex.test(ip) || ipv6Regex.test(ip);
        }

        isValidHostname(hostname: string): boolean {
            const hostnameRegex = /^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
            return hostnameRegex.test(hostname);
        }

        isValidPort(port: number): boolean {
            return Number.isInteger(port) && port >= 1 && port <= 65535;
        }

        parseURL(url: string): { protocol: string, hostname: string, port?: number, path: string } {
            try {
                const parsed = new URL(url);
                return {
                    protocol: parsed.protocol.replace(':', ''),
                    hostname: parsed.hostname,
                    port: parsed.port ? parseInt(parsed.port) : undefined,
                    path: parsed.pathname + parsed.search + parsed.hash
                };
            } catch (error) {
                throw createError(
                    `Invalid URL: ${url}`,
                    'INVALID_URL',
                    { url, error }
                );
            }
        }

        calculateSubnet(ip: string, cidr: number): { network: string, broadcast: string, range: string[] } {
            if (!this.isValidIP(ip)) {
                throw createError('Invalid IP address', 'INVALID_IP', { ip });
            }
            
            if (cidr < 0 || cidr > 32) {
                throw createError('Invalid CIDR notation', 'INVALID_CIDR', { cidr });
            }
            
            const ipParts = ip.split('.').map(Number);
            const mask = (0xFFFFFFFF << (32 - cidr)) >>> 0;
            
            const ipInt = (ipParts[0] << 24) + (ipParts[1] << 16) + (ipParts[2] << 8) + ipParts[3];
            const networkInt = (ipInt & mask) >>> 0;
            const broadcastInt = (networkInt | (0xFFFFFFFF >>> cidr)) >>> 0;
            
            const intToIP = (int: number) => [
                (int >>> 24) & 0xFF,
                (int >>> 16) & 0xFF,
                (int >>> 8) & 0xFF,
                int & 0xFF
            ].join('.');
            
            const network = intToIP(networkInt);
            const broadcast = intToIP(broadcastInt);
            
            const range: string[] = [];
            for (let i = networkInt + 1; i < broadcastInt; i++) {
                range.push(intToIP(i));
            }
            
            return { network, broadcast, range };
        }

        // Platform-specific implementations (stubs)
        private async getNetworkInterfacesBrowser(): Promise<NetworkInterface[]> {
            // Browser implementation is limited
            return [{
                name: 'browser',
                address: '127.0.0.1',
                netmask: '255.0.0.0',
                family: 'IPv4',
                mac: '00:00:00:00:00:00',
                internal: true,
                cidr: '127.0.0.1/8'
            }];
        }

        private async getNetworkInterfacesNode(): Promise<NetworkInterface[]> {
            // Node.js implementation would use os.networkInterfaces()
            throw createError('Node.js network interfaces not implemented', 'NOT_IMPLEMENTED');
        }

        private async pingBrowser(host: string, timeout: number): Promise<PingResult> {
            // Browser implementation using fetch with timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            
            try {
                const start = Date.now();
                await fetch(`https://${host}`, { 
                    method: 'HEAD', 
                    signal: controller.signal,
                    mode: 'no-cors'
                });
                const time = Date.now() - start;
                clearTimeout(timeoutId);
                
                return { host, alive: true, time };
            } catch {
                clearTimeout(timeoutId);
                return { host, alive: false };
            }
        }

        private async pingNode(host: string, timeout: number): Promise<PingResult> {
            // Node.js implementation would use ping command or net module
            throw createError('Node.js ping not implemented', 'NOT_IMPLEMENTED');
        }

        private async scanPortBrowser(host: string, port: number, timeout: number): Promise<PortScanResult> {
            // Browser implementation is very limited due to CORS
            return { host, port, open: false, error: 'Port scanning not supported in browser' };
        }

        private async scanPortNode(host: string, port: number, timeout: number): Promise<PortScanResult> {
            // Node.js implementation would use net.connect()
            throw createError('Node.js port scanning not implemented', 'NOT_IMPLEMENTED');
        }

        private async resolveDNSBrowser(hostname: string, recordType: string): Promise<DNSRecord[]> {
            // Browser implementation is limited
            throw createError('DNS resolution not supported in browser environment', 'OPERATION_NOT_SUPPORTED');
        }

        private async resolveDNSNode(hostname: string, recordType: string): Promise<DNSRecord[]> {
            // Node.js implementation would use dns module
            throw createError('Node.js DNS resolution not implemented', 'NOT_IMPLEMENTED');
        }

        private async reverseDNSBrowser(ip: string): Promise<string> {
            // Browser implementation is limited
            throw createError('Reverse DNS not supported in browser environment', 'OPERATION_NOT_SUPPORTED');
        }

        private async reverseDNSNode(ip: string): Promise<string> {
            // Node.js implementation would use dns.reverse()
            throw createError('Node.js reverse DNS not implemented', 'NOT_IMPLEMENTED');
        }

        private async getNetworkStatsNode(): Promise<NetworkStats[]> {
            // Node.js implementation would parse /proc/net/dev or use system commands
            throw createError('Node.js network stats not implemented', 'NOT_IMPLEMENTED');
        }

        private async getActiveConnectionsNode(): Promise<ConnectionInfo[]> {
            // Node.js implementation would parse netstat or /proc/net/tcp
            throw createError('Node.js active connections not implemented', 'NOT_IMPLEMENTED');
        }
    }

    // Default network utils instance
    export const network = new NetworkUtils();

    // Utility functions
    export function createNetworkUtils(): NetworkUtils {
        return new NetworkUtils();
    }

    export async function checkConnectivity(hosts: string[] = ['8.8.8.8', 'google.com']): Promise<boolean> {
        for (const host of hosts) {
            try {
                const result = await network.ping(host, 3000);
                if (result.alive) {
                    return true;
                }
            } catch {
                continue;
            }
        }
        return false;
    }

    export async function getNetworkInfo(): Promise<{
        interfaces: NetworkInterface[],
        publicIP: string,
        localIP: string,
        connectivity: boolean
    }> {
        const [interfaces, publicIP, localIP, connectivity] = await Promise.all([
            network.getNetworkInterfaces(),
            network.getPublicIP().catch(() => 'unknown'),
            network.getLocalIP().catch(() => '127.0.0.1'),
            checkConnectivity()
        ]);
        
        return { interfaces, publicIP, localIP, connectivity };
    }
}